## Nekhbet Language Specification. Version 0.1 (*draft*)

## Data Types

Nekhbet defines the following categories of object (value or reference) types:

* Value types
    * Primitive types - Types intrinsic to the language. Primitives cannot have members and cannot participate in inheritance.
    * Structure types - Types made from primitives and other compound types. Structure types can have both value and function members, and participate in inheritance.
    * Array types - Fixed size sequences of objects of the same type. Array types are declared by specifying the element type and the array extent inside of square braces (ex: `int32[8]`). Heap-allocated arrays can have dynamic extent specified as an expression.
* Reference types
    * Owning references - Object references that allow for automatic resource management. To declare a reference that does participate in GC (owning reference), the referenced type must be specified followed by `$` (ex: `int32 $`, `int32[8] $`). Owning references cannot reference a non-heap objects (static or stack objects), and can only be assigned from other owning references or be initialized via the `new` keyword (ex: `my_int : int32 $ = new int32(2);`). There is no constraints on the underlying implementation of owning references, however it is required that the referenced object is destroyed once the last reference to it is invalidated (exits scope or is re-assigned).
    * Non-owning references - References to object without automatic resource management. Such references are declared by using `&` after the referenced type (ex: `int32 &`). Non-owning references inherit the scope of the object they were assigned from (for example, reference initialized from a stack local may not exit the local's scope). Non-owning references may reference heap-allocated objects, by initializing the reference with the `new` operator and manually destroyed via the `delete` operator (ex: `my_int : int32 & = new int32;`, `delete my_int;`). Once an object is deleted, all references to it are invalidated. Owning references can be used to interface with native code.
    * Dynamic array references - Normally, references to array types include array's extent. This means, however, that such references may only be assigned from arrays of the same size. In order to be able to use arrays of arbitrary size (for example, heap-allocated arrays with extent defined by a non-constant expression), such references must omit the extent (leave square braces empty) during type declaration (ex: `my_arr : int32[] $ = new int32[my_size];`).
    * Non-nullable "required" references - Both non-owning and owning references can have value of `null` (which is the default value). To declare a reference as non-nullable, `!` must prefix the reference (ex: `int32 !&`, `int32[80]  !$` ). Using `!` will ensure that the reference never has the value of `null`. Required references cannot be default-constructed (they must be assigned from an object or a reference) and cannot be set to `null`.
    * Function "delegate" references - Delegates can be used to assign both "free" functions and lambdas. Delegates are declared by using the `delegate` keyword followed by its signature (ex: `my_func : delegate int32(bool)`). Internally, a delegate is equivalent to a pointer that either points to the target free function, or to a heap-allocated capturing lambda (non-capturing lambdas are equivalent to a free function).

### Type Qualifiers

Nekhbet defines the following type qualifiers:

*  `const` - Types qualified as const are considered immutable. Instances of such types cannot be modified after initialization. References to const-qualified types can reference a non-const object, however a non-const reference may not reference a const object.

Any qualifiers applied to reference types must be placed after the type of the referenced object. For example, `int32 const &` is an non-owning constant reference to `int32` while `const int32 &` is a non-owning reference to constant of `int32` type.

### Builtin Types

Builtin types are provided by the language.
Nekhbet defines the following builtin types.

#### Primitives

```
+-----------+--------------+-------------------+--------------------------------------------------------------+
| Type name | Size (bytes) | Alignment (bytes) | Description                                                  |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| Integral types                                                                                              |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| int8      | 1            | 1                 | 8-bit signed integer type                                    |
| uint8     | 1            | 1                 | 8-bit unsigned integer type                                  |
| int16     | 2            | 2                 | 16-bit signed integer type                                   |
| uint16    | 2            | 2                 | 16-bit unsigned integer type                                 |
| int32     | 4            | 4                 | 32-bit signed integer type                                   |
| uint32    | 4            | 4                 | 32-bit unsigned integer type                                 |
| int64     | 8            | 8                 | 64-bit signed integer type                                   |
| uint64    | 8            | 8                 | 64-bit unsigned integer type                                 |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| Floating-point types                                                                                        |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| float     | 4            | 4                 | 32-bit floating point type (IEEE 754-1985)                   |
| double    | 8            | 8                 | 64-bit floating point type (IEEE 754-1985)                   |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| Other primitives                                                                                            |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| bool      | 1            | 1                 | Boolean type (1 = true, 0 = false)                           |
| char      | 1            | 1                 | UTF-8/ASCII character                                        |
+-----------+--------------+-------------------+--------------------------------------------------------------+
```

#### Structure Types

```
+-----------+--------------+-------------------+--------------------------------------------------------------+
| Type name | Size (bytes) | Alignment (bytes) | Description                                                  |
+-----------+--------------+-------------------+--------------------------------------------------------------+
| string    | 24           | 8                 | UTF-8 string with SSO                                        |
| type      | 8            | 8                 | Reference to internal reflection info about a type           |
+-----------+--------------+-------------------+--------------------------------------------------------------+
```

### Type Casting & Type Info

Type casting is done via the use of the `as` operator followed by the target type (ex: `my_int : int32 = my_float as int32`).

Casts of value types are only allowed between types with defined casts. Such type casts are either built into the language (such as casts between primitives) or may be provided via overload of the `as` operator. 

Reference types are only allowed to be cast between references of related (via inheritance) types. Normally, a type reference may only be cast to its parent type, however, if the type is declared as `dynamic` (instances of such types contain a reference to their type info, ex: `dynamic class my_type inherits ... { ... }`), such type may be down-casted.

To get reflected type information from an instance of a type, one must use the `typeof` keyword, followed by an expresion or a type (ex: `my_info : type = typeof int32;`, `my_info : type = typeof (1 * 0.8f);`).  To get the type of a referenced variable from its reference, the de-referencing `typeof*` keyword must be used.

## Object Lifetime, Storage & Initialization.

An object's storage duration is defined by its lifetime category. Lifetime categories are separated into three major categories (global, external & local). References and capturing lambdas inherit the lifetime category of the objects assigned to them (or captured, in the case of lambdas). Nekhbet defines the following lifetime categories:

* Global lifetime - Lifetime of objects whose storage duration is not bound to a specific scope.
    * Static lifetime - Variables declared as `static`, builtin variables, free-floating functions and non-capturing lambdas have the global lifetime. Functions & builtin variables are initialized by the runtime before any user code runs, after that, global variables (variables declared as `static`) are initialized. Static initialization should follow the order in which the variables are declared. The declaration order guarantee states that if variable `a` was declared prior to variable `b`, it should be initialized before it. References that are default-initialized (or set to `null`) have static lifetime (since `null` has static lifetime).
    * Heap lifetime - Objects allocated on the heap via the use of the `new` operator followed by the object's type optional construction arguments or list initializer (ex: `new int32(6)`, `new int32[8]{1, 2, 3, 4}`).
* External lifetime - Variables whose storage duration is unknown, but are guaranteed to live longer than the current scope (for example, references passed as function arguments).
* Local lifetime - Variables declared as stack locals and class members have local lifetime. Objects that have local lifetime category are not allowed to exit their scope (for example, a reference that inherits the local lifetime of a class member may not be returned from that class), however they may enter any "child" scopes (such as being passed to a function as arguments).
    * Class lifetime - Variables declared as non-static members of a class.
    * Block lifetime -Variables declared within a function scope or an inner scope of a control statement (such an `if` statement).